18/07/2025

(typing casting)

// Widening casting (Automatically)

// small type to larger type

// byte->short->int->long->float->double

// Narrow casting (Manually)

// Larger type to small type data

// double->float->long->int->short->byte

https://choosemymentor-my.sharepoint.com/:f:/g/personal/abuswale_techademy_com/EhZV93MXbbZBkLq9W3bFSmkBPXz7ibI7cLR3wWgy7pBz9A?e=y234pb

Java is a high-level, object-oriented programming 
	language. 
-	This language is very easy to learn and widely used. 
-	It is known for its platform independence,reliability 
	and security. It follows one principle, that is:
	"Write Once, Run Anywhere"(WORA) principle.
 
	Mycode.java------->javac------->ByteCode(Mycode.class)----> java Mycode------> Output
	(SourceCode)			(Intermediate Code)	    JVM translates the IC to MC	
 
	JVM					JVM				JVM
	WINDOWS(JDK)				LINUX(JRE)			MAC(JRE)
	-------					-----				---
	(WRITE)Mycode.java	javac		(Run)java Mycode(ByteCode)
	Every OS has its own JVM. So "JVM is PLATFORM DEPENDENT"
	JAVA is "PLATFORM INDEPENDENT"
 
Java's origin
-------------
 
-	Java's history begins in 1991 at Sun Microsystems, 
	where a team led by "James Gosling" aimed to create a 
	new programming language for digital devices.
 
-	Initially called Oak, it was later renamed Java, 
	inspired by Indonesian coffee beans. 
-	The language's core principle of "Write Once, 
	Run Anywhere" (platform independence) fueled its 
	rapid adoption, especially with the rise of the 
	internet. 

 
Java Versions
==============
1991-1994: The Green Project and Oak. Sun Microsystems' 
"Green Team" (including Gosling, Mike Sheridan, 
and Patrick Naughton) initiated the project to develop 
a language for embedded systems, focusing on consumer 
electronics. The initial language was called Oak, 
named after an oak tree outside Gosling's office.
 
1995: Java's Public Debut. 
Sun Microsystems officially 
launched Java, emphasizing its platform-independent 
nature. The "HotJava" browser was introduced to showcase 
Java applets.
 
1996: First Version (1.0). The initial version of Java, 1.0,
was released.
 
1997: Standardization. 
Java was standardized by ISO and ANSI, solidifying its 
position as a reliable language.
 
1999: Java 2 Platform (J2SE, J2EE, J2ME). Java was divided 
into three editions to cater to different needs.
 
2004: Java 5 and Enhancements. Java 5 introduced significant 
language enhancements, including generics and other 
features.
 
2006: Open Sourcing. 
Sun Microsystems made Java open source by releasing 
the OpenJDK.
 
2010: Oracle Acquisition. 
Oracle acquired Sun Microsystems,taking over Java's 
development and future.
 
2014: Java 8 and Modern Features. 
Java 8 brought in features like lambda expressions and a new Date and Time 
API.
 
2017: Java 9 and Modularization. 
Java 9 introduced the 
module system (JPMS) for modularizing applications.
 
Continued Evolution: Java continues to evolve with regular 
releases, incorporating new features and improvements. 	
 
The latest  version of Java is: Java 21 and Java 24
 
 
Features of Java:

=================

1.	Simple Syntax

	Java syntax is very straightforward and very easy to 

	learn. Java removes complex features like pointers 

	and multiple inheritance, which makes it a good 

	choice for beginners.	

2.	Object Oriented

	Java is a pure object-oriented language. It supports 

	core OOP concepts like:

	1.	Class - It is a bluprint of the object.

			  - It is a collection of "SIMILAR" objects.

		Car(CLASS) - BMW,Audi,Mercedez,Aston Martin(OBJECTS)

		HONDA(Class) - HONDA CRV,HONDA CIVIC,HONDA ACCORD,

					   HONDA CITY.	

			(VEHICLES)

			Truck,Bus,Trailer,

			 - It is a logical construct.

	2.	Objects - 	It is a physical construct.It is an 

					instance of the class.

	3.	Inheritance - A CHILD inherits the properties or behavoiur

					 from their PARENTS.

	4.	Encapsulation - Wrapping of data into a single unit and 

						that unit has a name.

	5.	Abstraction - Hiding unecessary data from the user so that

						he/she should be concentrate on the logic.

						printf("Hello");

	6.	Polymorphism - 1 single entity can have many forms

						POLY(Many) + MORPHISM(Forms)

3.	Platform Independent

	Java is platform-independent because of Java Virtual 

	Machine (JVM).
 
-	When we write Java code, it is first compiled by the 

	compiler and then converted into bytecode(intermediate code)

	(which is platform-independent).

-	This byte code can run on any platform which has 

	JVM installed.	

	Source code				  ByteCode

	abc.java----->javac------abc.class----java abc----output

	=======================================================

	JVM - Java Virtual Machine - It is PLATFORM DEPENDENT.

	========================================================

	JVM						JVM					JVM

	WINDOWS					LINUX				MAC

	javac abc.java			java abc			java abc	

	(WORA)

4.	Interpreted

-	Java code is not directly executed by the computer. 

	It is first compiled into bytecode. This byte code is 

	then understand by the JVM. This enables Java to run 

	on any platform without rewriting code.	

5.	Scalable

-	Java can handle both small and large-scale applications.

	Java provides features like multithreading and 

	distributed computing that allows developers to 

	manage loads more easily.	

6.	Portable

-	When we write a Java program, the code first get 

	converted into bytecode and this bytecode does not 

	depend on any operating system or any specific computer. 

	We can simply execute this bytecode on any platform with 

	the help of JVM. Since JVMs are available on all the OS's 

	and that's why we can run the same Java program on 

	different platforms.

7.	Secured and Robust

-	Java is a reliable programming language because it 

	can catch mistakes early while writing the code and 

	also keeps checking for errors when the program is 

	running. It also has a feature called exception 

	handling that helps deal with unexpected problems 

	smoothly.	

8.	Memory Management

-	Memory management in Java is automatically handled 

	by the Java Virtual Machine (JVM).
 
-	Java garbage collector reclaim memory from objects that 

	are no longer needed.

-	"Memory for objects are allocated in the "HEAP".
 
-	Method calls and local variables are stored in the 

	STACK.	

9.	High Performance

-	Java is faster than old interpreted languages. Java 

	program is first converted into bytecode which is 

	faster than interpreted code. 	

10.	Multithreading

-	Multithreading in Java allows multiple threads to run 

	at the same time.

-	It improves CPU utilization and enhancing performance 

	in applications that require concurrent task execution.	

11.	Rich Standard Library

-	Java provides various pre-built tools and libraries 

	which is known as Java API. Java API is used to cover 

	tasks like file handling, networking, database connectivity 

	(JDBC), security, etc. 	

12.	Functional Programming Features

-	Since Java 8, the language has introduced functional 

	programming features such as:	

	1.	lambda expression

	2.	Stream API

	3.	Functional Interfaces

13.	Integration with Other Technologies

-	Java can easily work with many languages and tools as 

	well. For example, Java can connect with C and C++ 

	with the help of Java Native Interface (JNI). 

	Java is very popular for building websites and 

	webservices like RESTful & SOAP.	

14.	Support for Mobile and Web Application

-	Java offers support for both web and mobile applications.	
 
15.	Documentation and Community Support

-	Java provide documentation which includes guides, 

	API references, and tutorials for easy learning. 

	Java has a large and active global community 

	contributing to open-source projects, and resources.		
 JDK, JRE and JVM
=================
JDK, JRE, and JVM are three core components of the Java 
ecosystem, each with distinct roles. 
-	The JDK (Java Development Kit) is a software 
	development kit used for creating Java applications. 
	JDK ----> CREATE JAVA APPS.
-	The JRE (Java Runtime Environment) provides the 
	environment for running Java applications.
	JRE ----> RUN JAVA APPS
-	The JVM (Java Virtual Machine) is the engine that 
	executes Java bytecode, enabling platform independence. 
	JVM ----> EXECUTES BYTECODE

 
JDK (Java Development Kit):
It's a kit for Java developers, providing tools like 
compilers, debuggers, and documentation generators. 
It includes the JRE, so when you install the JDK, you also 
get the environment to run Java programs. 
Essentially, it's what you need to develop Java code.
 
JRE (Java Runtime Environment): 
It provides the runtime environment for Java applications, including the JVM and necessary libraries. 
It's what you need to run Java applications, 
but not to develop them. 
It's platform-dependent, meaning you need a JRE specific 
to your operating system.
 
JVM (Java Virtual Machine):
It's the core of the Java runtime environment, responsible for executing Java bytecode. 
It provides platform independence by abstracting away the 
underlying hardware and operating system. 
JVM - java abc(bytecode)
==========================================================
It interprets bytecode into machine-specific instructions,
allowing Java code to run on different platforms. 
===========================================================
It's a key component of the JRE.

Java Keywords
==============
-	In Java, keywords are predefined, reserved words that 
	have specific meanings to the Java compiler and cannot 
	be used as identifiers (e.g., variable names, method names,
	class names). 
Below is the list of common Java keywords and their 
general purposes:
=====================================================
1.	Access Modifiers: public, private, protected, static, 
	final, abstract
 
2.	Class and Object related: class, interface, enum, 
	extends, implements, new, this, super, instanceof
 
3.	Data Types: byte, short, int, long, float, double, 
	boolean, char, void
 
4.	Control Flow: if, else, switch, case, default, for, 
	while, do, break, continue, return
 
5.	Exception Handling: try, catch, finally, throw, throws
 
6.	Package and Import: package, import
 
7.	Other: transient, volatile, strictfp, assert, 
	synchronized, native
 
8.	Keywords added in newer versions: var (Java 10), 
	record (Java 16), sealed, permits (Java 17)	
				======================
// Comments are used to increase the readability of the program.

//A Basic Java Program

/*

Below is the basic 

program for the begiunners !!!

*/
 
// Define a class

class MyClass{

	//JVM Entry Point

	public static void main(String[] args){

		// Print the text

		System.out.print("Hello Learners..");

	}

}
 
class DataType{

	//String[] args - It is a command line argument

	public static void main(String[] args){

		System.out.println("args[0]: "+args[0]);

		System.out.println("args[1]: "+args[1]);

		System.out.println("Addition: "+(args[0]+args[1]));

		// Convert the String to int data type 

		//using WRAPPER CLASS(Integer)

		int num1 = Integer.parseInt(args[0]);

		int num2 = Integer.parseInt(args[1]);

		System.out.println(" New Addition is: "+(num1+num2));

		//Convert the String to a double data type

		double d1 = Double.parseDouble(args[2]);

		double d2 = Double.parseDouble(args[3]);

		System.out.println("Decimal Addition is: "+(d1+d2));

		int x=234;

		x=x+100;

		System.out.println("X: "+x);

		String y = "123";

		y= y+100;

		System.out.println("Y: "+y);

		// Convert the integer to a String

		System.out.println("New Str: "+String.valueOf(x)+200);

		String str = String.valueOf(x);

		str = str+100;

		System.out.println("Str: "+str);

		//Task

		System.out.println("Java"+20+30);

		System.out.println(20+30+"Java"+20+30);

		//System.out.println("Args[4]: "+args[4]);

	}

}	

 class DataType{

	//String[] args - It is a command line argument

	//public static void main(String[] args){

	// Variable argument 

	static public void main(String...args){

		System.out.println("args[0]: "+args[0]);

		System.out.println("args[1]: "+args[1]);

		System.out.println("Addition: "+(args[0]+args[1]));

		// Convert the String to int data type 

		//using WRAPPER CLASS(Integer)

		int num1 = Integer.parseInt(args[0]);

		int num2 = Integer.parseInt(args[1]);

		System.out.println(" New Addition is: "+(num1+num2));

		//Convert the String to a double data type

		double d1 = Double.parseDouble(args[2]);

		double d2 = Double.parseDouble(args[3]);

		System.out.println("Decimal Addition is: "+(d1+d2));

		int x=234;

		x=x+100;

		System.out.println("X: "+x);

		String y = "123";

		y= y+100;

		System.out.println("Y: "+y);

		// Convert the integer to a String

		System.out.println("New Str: "+String.valueOf(x)+200);

		String str = String.valueOf(x);

		str = str+100;

		System.out.println("Str: "+str);

		//Task

		System.out.println("Java"+20+30);

		System.out.println(20+30+"Java"+20+30);

		//System.out.println("Args[4]: "+args[4]);

		System.out.println("Welcome");

	}

}	

Garbage Collection
===================
-	Garbage Collection (GC) in Java is an automatic memory 
	management process that frees up memory by identifying 
	and reclaiming objects that are no longer referenced or 
	needed by the program. 
	This automated process is a key feature of the Java 
	Virtual Machine (JVM) and helps prevent memory leaks 
	and simplifies development by eliminating the need for 
	manual memory deallocation.
 
 
How it works: 
=============
 
Object Creation and Heap Memory:
----------------------------------
When a Java program runs, objects are created and stored 
in the heap memory, which is a dedicated portion of memory 
managed by the JVM.
 
Identifying Unreachable Objects:
--------------------------------
The Garbage Collector continuously monitors the heap and 
identifies objects that are no longer reachable or 
referenced by any part of the running program. 
This means there are no active references (variables, 
data structures, etc.) pointing to these objects.
 
Reclaiming Memory:
------------------
Once an object is determined to be unreachable, the 
Garbage Collector reclaims the memory occupied by that 
object, making it available for new object allocations.
 
Automatic Process:
------------------
Unlike languages like C or C++ where developers explicitly 
manage memory allocation and deallocation, 
Java's GC handles this automatically. This reduces the 
risk of memory-related errors and allows developers to 
focus on application logic.
 

JVM Architecture
The Java Virtual Machine (JVM) is the engine that enables Java's platform independence, allowing Java programs to run on any device or operating system that has a JVM implementation.
Here's a breakdown of the JVM architecture:
JVM Architecture Overview
        +-------------------------------------------+
         |               Class Loader Subsystem      |
        +-------------------------------------------+
                         ↓
        +-------------------------------------------+
         |              Runtime Data Areas           |
         |   (Method Area, Heap, Stack, PC Register, |
         |    Native Method Stack)                   |
        +-------------------------------------------+
                         ↓
        +-------------------------------------------+
         |              Execution Engine             |
         |   (Interpreter, JIT Compiler, GC, etc.)   |
        +-------------------------------------------+
                         ↓
        +-------------------------------------------+
         |         Native Interface (JNI)            |
        +-------------------------------------------+
                         ↓
        +-------------------------------------------+
         |         Native Method Libraries           |
        +-------------------------------------------+


 
Key Components Explained
1. Class Loader Subsystem
Loads .class files (bytecode) into memory.
Performs:
Loading
Linking (verifying, preparing, resolving)
Initialization
Ensures classes are loaded only once.

2. Runtime Data Areas
These are memory areas used during program execution:
a. Method Area
Stores class-level data like:
Class structure
Field & method data
Static variables

b. Heap
Stores objects and instance variables.
Shared among all threads.

c. Java Stack (per thread)
Stores:
Method frames
Local variables
Operand stacks

Each thread has its own stack.

d. Program Counter (PC) Register
Holds the address of the current instruction being executed per thread.

e. Native Method Stack
Supports native methods written in C/C++ (outside Java).
Uses JNI (Java Native Interface).


 
3. Execution Engine
Executes the bytecode.
a. Interpreter
Reads and executes bytecode line by line.
Slower but quick to start.

b. JIT Compiler (Just-In-Time)
Converts bytecode to native machine code.
Improves performance by caching frequently-used code.

c. Garbage Collector
Automatically manages memory.
Reclaims memory from unused objects in the heap.

4. Native Interface (JNI)
Enables Java code to interact with native applications and libraries (written in C, C++, etc.).

5. Native Method Libraries
System-level libraries (e.g., libc.so on Linux, msvcrt.dll on Windows).
Summary
Component
	
       Role


Class Loader
	
       Loads .class files into JVM


Runtime Data Areas
	
       Stores data, code, and objects


Execution Engine
	
       Executes the program


JNI & Native Libs
	
       Bridge between Java and native code
 
                                                                          ------------------
.

Data types in java

===================

Java categorizes data types into two main groups: 

Primitive data types and non-primitive(or reference)data 

types.
 
==============================================================

NOTE: We cannot create the OBJECT of any PRIMITIVE data type.

===============================================================

Due to the presence of PRIMITIVE data types, 

JAVA is not "TRUE" ObjectOrientedLanguage.
 
Primitive Data Types:

---------------------

These are fundamental data types that directly store values and are predefined in Java. There are eight primitive data types:
 
Integral Types:

---------------

1.	byte: 8-bit signed integer(1 byte) (-128 to 127).

2.	short: 16-bit signed integer(2 bytes) (-32,768 to 32,767).

3.	int: 32-bit signed integer(4 bytes) (-2,147,483,648 to 2,147,483,647). This is the default integer type.

4.	long: 64-bit signed integer(8 bytes) (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807). Used for very large integer values.
 
Floating-Point Types:

---------------------

1.	float: 32-bit(4 bytes) single-precision floating-point number.

2.	double: 64-bit(8 bytes) double-precision floating-point number. This is the default floating-point type.
 
Character Type:

---------------

1.	char: 16-bit(2 bytes) Unicode character (stores a single character).
 
Boolean Type:

-------------

1.	boolean: Stores true or false values.
 
Non-Primitive (Reference) Data Types:

=====================================

These data types do not store the actual values directly 

but rather store references (memory addresses) to objects. They are created by the programmer and include:

1.	Classes: User-defined blueprints for creating objects.
 
2.	Interfaces: Blueprints of a class that define methods 

	but do not implement them.
 
3.	Arrays: Collections of elements of the same data type.

4.	Strings: A sequence of characters (a special class in 

	Java).
 PATH and CLASSPATH
==================
-	The CLASSPATH specifies where the JVM looks for .class 
	files.
-	PATH (a separate environment variable) specifies 
	where the operating system looks for executable 
	programs (like java and javac).
 
-	Using the -classpath option is generally preferred 
	over modifying the environment variable for better 
	isolation and project-specific control.

Which component of the JVM is responsible for loading class files?
a) Class Loader
b) Bytecode Verifier
c) Interpreter
d) JIT Compiler
Answer: a) Class Loader

Explanation: The Class Loader loads class files into the JVM at runtime.
The part of JVM responsible for converting bytecode into machine code at runtime is:
a) Interpreter
b) JIT Compiler
c) Garbage Collector
d) Class Loader
Answer: b) JIT Compiler

Explanation: The JIT (Just-In-Time) compiler improves performance by compiling bytecode to native code at runtime.
Which memory area in the JVM stores class structures like metadata and static variables?
a) Stack
b) Heap
c) Method Area
d) Program Counter
Answer: c) Method Area
Explanation: The method area holds class-related data, including static fields and method definitions.

What does the Java Stack store?
a) Class-level metadata
b) Object references only
c) Local variables and method call frames
d) All class instances
Answer: c) Local variables and method call frames
Explanation: Each thread has a stack storing frames for each method call.

The Program Counter (PC) register in JVM is used to:
a) Track memory allocation
b) Keep the address of the next bytecode instruction
c) Manage method parameters
d) Store constant values
Answer: b) Keep the address of the next bytecode instruction
Explanation: The PC register points to the address of the JVM instruction being executed.

Which memory area in JVM is shared among all threads?
a) Stack
b) Heap
c) Program Counter
d) Native Method Stack
Answer: b) Heap
Explanation: The heap is used to allocate memory for objects and is shared across all threads.


 
Garbage collection in Java primarily aims to:
a) Optimize bytecode
b) Manage CPU usage
c) Free memory by destroying unreachable objects
d) Compile Java programs
Answer: c) Free memory by destroying unreachable objects
Explanation: The GC reclaims memory occupied by objects no longer referenced.

Which of the following is a valid garbage collection algorithm used in Java?
a) Mark and Swap
b) Sweep and Compact
c) Mark and Sweep
d) Allocate and Destroy
Answer: c) Mark and Sweep
Explanation: “Mark and Sweep” is a classic algorithm used in many JVM GC implementations.

In Java, objects become eligible for garbage collection when:
a) They are assigned null
b) The program ends
c) They are no longer reachable
d) They are private
Answer: c) They are no longer reachable
Explanation: The key condition is unreachability from any live thread.

Which of the following is not a primitive data type in Java?
a) byte
b) short
c) String
d) boolean
Answer: c) String
Explanation: String is a class, not a primitive type.

Which data type is used to store 64-bit integer values in Java?
a) int
b) long
c) double
d) short
Answer: b) long
Explanation: long is a 64-bit signed integer.

What is the default value of a boolean variable in Java (class level)?
a) true
b) false
c) null
d) 0
Answer: b) false
Explanation: All uninitialized boolean fields in a class default to false.


 
Which of the following can store decimal values in Java?
a) int and byte
b) float and double
c) char and short
d) long and int
Answer: b) float and double
Explanation: float (32-bit) and double (64-bit) are used for real numbers.
 
